<pre class=metadata>
Title: Native File System
Shortname: native-file-system
Abstract: This document defines a web platform API that lets websites gain write access to the
  native file system. It builds on [[FILE-API]], but adds lots of new functionality on top.
Status: CG-DRAFT
ED: https://wicg.github.io/native-file-system/
Level: 1
Editor: Marijn Kruisselbrink, Google, mek@chromium.org, w3cid 72440
Group: WICG
Repository: wicg/native-file-system
Indent: 2
Complain About: accidental-2119 yes, missing-example-ids yes
Markup Shorthands: css no, markdown yes
</pre>

<pre class=link-defaults>
spec:fetch; type:interface; text:ReadableStream
</pre>

<pre class=anchors>
</pre>

<style>
.domintro dt {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;

    padding-top: 0.5em;
    padding-bottom: 1em;
}
.domintro dt a {
    color: inherit; border-bottom-style: none;
}
.domintro dt code {
    font-size: inherit;
}
</style>

# Introduction # {#introduction}

*This section is non-normative.*

TODO

This provides similar functionality as earlier drafts of the [[file-system-api]] as well as the
[[entries-api]], but with a more modern API.

# Files and Directories # {#files-and-directories}

## Concepts ## {#concepts}

A <dfn>entry</dfn> is either a [=file entry=] or a [=directory entry=].

Each [=/entry=] has an associated <dfn for=entry>name</dfn>.

A <dfn lt="file|file entry">file entry</dfn> additionally consists of <dfn for="file entry">binary
data</dfn> and a <dfn for="file entry">modification timestamp</dfn>.

A <dfn lt="directory|directory entry">directory entry</dfn> additionally consists of a [=/set=] of
<dfn for="directory entry">entries</dfn>. Each member is either a [=file=] or a [=directory=].

Issue: TODO: Explain how entries map to files on disk (multiple entries can map to the same file or
directory on disk but doesn't have to map to any file on disk).

## The {{FileSystemHandle}} interface ## {#api-filesystemhandle}

<xmp class=idl>
dictionary FileSystemHandlePermissionDescriptor {
  boolean writable = false;
};

[Exposed=(Window,Worker), SecureContext]
interface FileSystemHandle {
  readonly attribute boolean isFile;
  readonly attribute boolean isDirectory;
  readonly attribute USVString name;

  Promise<PermissionState> queryPermission(optional FileSystemHandlePermissionDescriptor descriptor);
  Promise<PermissionState> requestPermission(optional FileSystemHandlePermissionDescriptor descriptor);
};
</xmp>

A {{FileSystemHandle}} object represents a [=/entry=]. Each {{FileSystemHandle}} object is assocaited
with a <dfn for=FileSystemHandle>entry</dfn> (a [=/entry=]). Multiple separate objects implementing
the {{FileSystemHandle}} interface can all be associated with the same [=/entry=] simultaneously.

<div class="note domintro">
  : |handle| . {{FileSystemHandle/isFile}}
  :: Returns true iff |handle| is a {{FileSystemFileHandle}}.

  : |handle| . {{FileSystemHandle/isDirectory}}
  :: Returns true iff |handle| is a {{FileSystemDirectoryHandle}}.

  : |handle| . {{FileSystemHandle/name}}
  :: Returns the [=entry/name=] of the entry represented by |handle|.
</div>

The <dfn attribute for=FileSystemHandle>isFile</dfn> attribute must return true if the associated
[=FileSystemHandle/entry=] is a [=file entry=], and false otherwise.

The <dfn attribute for=FileSystemHandle>isDirectory</dfn> attribute must return true if the
associated [=FileSystemHandle/entry=] is a [=directory entry=], and false otherwise.

The <dfn attribute for=FileSystemHandle>name</dfn> attribute must return the [=entry/name=] of the
associated [=FileSystemHandle/entry=].

### The {{FileSystemHandle/queryPermission()}} method ### {#api-filesystemhandle-querypermission}

Issue: the currently described API here assumes a model where it is not possible to have a
    write-only handle. I.e. it is not possible to have or request write access without also having
    read access. There definitely are use cases for write-only handles (i.e. directory downloads),
    so we might have to reconsider this.

<div class="note domintro">
  : |status| = await |handle| . {{FileSystemHandle/queryPermission()|queryPermission}}({ {{FileSystemHandlePermissionDescriptor/writable}} = false })
  : |status| = await |handle| . {{FileSystemHandle/queryPermission()}}
  :: Queries the current state of the read permission of this handle. If this returns `"prompt"`
     the website will have to call {{FileSystemHandle/requestPermission()}} before any
     operations on the handle can be done. If this returns `"denied"` any operations will reject.

     Usually handles returned by {{chooseFileSystemEntries}} will initially return `"granted"` for
     their read permission state, however other than through the user revoking permission, a handle
     retrieved from IndexedDB is also likely to return `"prompt"`.

  : |status| = await |handle| . {{FileSystemHandle/queryPermission()|queryPermission}}({ {{FileSystemHandlePermissionDescriptor/writable}} = true })
  :: Queries the current state of the write permission of this handle. If this returns `"prompt"`,
     attempting to modify the file or directory this handle represents will require user activation
     and will result in a confirmation prompt being shown to the user. However if the state of the
     read permission of this handle is also `"prompt"` the website will need to call
     {{FileSystemHandle/requestPermission()}}. There is no automatic prompting for read access when
     attempting to read from a file or directory.
</div>

<div algorithm>
The <dfn method for=FileSystemHandle>queryPermission(|descriptor|)</dfn> method, when invoked, must run these steps:

1. TODO

</div>

### The {{FileSystemHandle/requestPermission()}} method ### {#api-filesystemhandle-requestpermission}

<div class="note domintro">
  : |status| = await |handle| . {{FileSystemHandle/requestPermission()|requestPermission}}({ {{FileSystemHandlePermissionDescriptor/writable}} = false })
  : |status| = await |handle| . {{FileSystemHandle/requestPermission()}}
  :: If the state of the read permission of this handle is anything other than `"prompt"`, this
     will return that state directly. If it is `"prompt"` however, user activation is needed and
     this will show a confirmation prompt to the user. The new read permission state is then
     returned, depending on the user's response to the prompt.

  : |status| = await |handle| . {{FileSystemHandle/requestPermission()|requestPermission}}({ {{FileSystemHandlePermissionDescriptor/writable}} = true })
  :: If the state of the write permission of this handle is anything other than `"prompt"`, this
     will return that state directly. If the status of the read permission of this handle is
     `"denied"` this will return that.

     Otherwise the state of the write permission is `"prompt"` and this will show a confirmation
     prompt to the user. The new write permission state is then returned, depending on what the user
     selected.
</div>

<div algorithm>
The <dfn method for=FileSystemHandle>requestPermission(|descriptor|)</dfn> method, when invoked, must run these steps:

1. TODO

</div>

## The {{FileSystemFileHandle}} interface ## {#api-filesystemfilehandle}

<xmp class=idl>
dictionary FileSystemCreateWriterOptions {
  boolean truncate = true;
  boolean atomic = true;
};

[Exposed=(Window,Worker), SecureContext]
interface FileSystemFileHandle : FileSystemHandle {
  Promise<File> getFile();
  Promise<FileSystemWriter> createWriter(optional FileSystemCreateWriterOptions options);
};
</xmp>

Issue: boolean's that default to "true" can be confusing (see comment in
https://heycam.github.io/webidl/#idl-dictionaries). We should try to come up with other names
without ending up with double negations.

### The {{FileSystemFileHandle/getFile()}} method ### {#api-filesystemfilehandle-getfile}

<div class="note domintro">
  : |file| = await |fileHandle| . {{FileSystemFileHandle/getFile()}}
  :: Returns a {{File}} representing the state on disk of the entry represented by |handle|.
</div>

<div algorithm>
The <dfn method for=FileSystemFileHandle>getFile()</dfn> method, when invoked, must run these steps:

1. TODO

</div>

### The {{FileSystemFileHandle/createWriter()}} method ### {#api-filesystemfilehandle-createwriter}

<div class="note domintro">
  : |writer| = await |fileHandle| . {{FileSystemFileHandle/createWriter()}}
  : |writer| = await |fileHandle| . {{FileSystemFileHandle/createWriter()|createWriter}}({ {{FileSystemCreateWriterOptions/atomic}}: true })
  : |writer| = await |fileHandle| . {{FileSystemFileHandle/createWriter()|createWriter}}({ {{FileSystemCreateWriterOptions/truncate}}: |truncate|, {{FileSystemCreateWriterOptions/atomic}}: true })
  :: Returns a {{FileSystemWriter}} that can be used to write to the file. Any changes made through
     |writer| won't be reflected in the file represented by |fileHandle| until its
     {{FileSystemWriter/close()}} or {{FileSystemWriter/flush()}} methods are called.
     User agents try to ensure that no partial writes happen, i.e. the file represented by
     |fileHandle| will either contains its old contents or it will contain whatever data was written
     through |writer| up until one of these methods was called.

     This is typically implemented by writing data to a temporary file, and only replacing the file
     represented by |fileHandle| with the temporary file when the writer is closed.

     If |truncate| is `true` or not specified, the temporary file starts out empty, otherwise the
     existing file is first copied to this temporary file.

   : |writer| = await |fileHandle| . {{FileSystemFileHandle/createWriter()|createWriter}}({ {{FileSystemCreateWriterOptions/atomic}}: false })
   : |writer| = await |fileHandle| . {{FileSystemFileHandle/createWriter()|createWriter}}({ {{FileSystemCreateWriterOptions/truncate}}: |truncate|, {{FileSystemCreateWriterOptions/atomic}}: false })
   :: Returns a {{FileSystemWriter}} that can be used to write to the file. Any changes made through
      |writer| might not be reflected in the file represented by |fileHandle| until its
      {{FileSystemWriter/close()}} or {{FileSystemWriter/flush()}} methods are called.
      User agents are free to either flush changes to the file as they are made, or batch them
      up (possibly by writing to some kind of change log) until {{FileSystemWriter/close()}} or
      {{FileSystemWriter/flush()}} is called. Specifically for less trusted websites, user agents
      should probably batch up changes so that malware scanners or other security checks can be
      performed before actually flushing changes to disk.

      If |truncate| is true or not specified, the file will start out empty.
</div>

<div algorithm>
The <dfn method for=FileSystemFileHandle>createWriter(|options|)</dfn> method, when invoked, must run these steps:

1. TODO

</div>

## The {{FileSystemDirectoryHandle}} interface ## {#api-filesystemdirectoryhandle}

<xmp class=idl>
dictionary FileSystemGetFileOptions {
  boolean create = false;
};

dictionary FileSystemGetDirectoryOptions {
  boolean create = false;
};

dictionary FileSystemRemoveOptions {
  boolean recursive = false;
};

[Exposed=(Window,Worker), SecureContext]
interface FileSystemDirectoryHandle : FileSystemHandle {
  Promise<FileSystemFileHandle> getFile(USVString name, optional FileSystemGetFileOptions options);
  Promise<FileSystemDirectoryHandle> getDirectory(USVString name, optional FileSystemGetDirectoryOptions options);

  // This really returns an async iterable, but that is not yet expressable in WebIDL.
  object getEntries();

  Promise<sequence<USVString>?> resolve(FileSystemHandle handle);

  Promise<void> removeEntry(USVString name, optional FileSystemRemoveOptions options);
};
</xmp>

Issue: Should we have separate getFile and getDirectory methods, or just a single getChild/getEntry
method?

Issue: Having getFile methods in both FileSystemDirectoryHandle and FileSystemFileHandle, but with
very different behavior might be confusing? Perhaps rename at least one of them (but see also
previous issue).

Issue: Should getEntries be its own method, or should FileSystemDirectoryHandle just be an async
iterable itself?

### The {{FileSystemDirectoryHandle/getFile()}} method ### {#api-filesystemdirectoryhandle-getfile}

<div class="note domintro">
  : |fileHandle| = await |directoryHandle| . {{FileSystemDirectoryHandle/getFile()|getFile}}(|name|)
  : |fileHandle| = await |directoryHandle| . {{FileSystemDirectoryHandle/getFile()|getFile}}(|name|, { {{FileSystemGetFileOptions/create}}: false })
  :: Returns a handle for a file named |name| in the directory represented by |directoryHandle|. If
     no such file exists, this rejects.

  : |fileHandle| = await |directoryHandle| . {{FileSystemDirectoryHandle/getFile()|getFile}}(|name|, { {{FileSystemGetFileOptions/create}}: true })
  :: Returns a handle for a file named |name| in the directory represented by |directoryHandle|. If
     no such file exists, this creates a new file. If no file with named |name| can be created this
     rejects. Creation can fail because there already is a directory with the same name, because the
     name uses characters that aren't supported in file names on the underlying file system, or
     because the user agent for security reasons decided not to allow creation of the file.

     This operation requires write permission, even if the file being returned already exists. If
     this handle doesn't already have write permission, this could result in a prompt being shown to
     the user. To get an existing file without needing write permission, call this method
     with <code>{ {{FileSystemGetFileOptions/create}}: false }</code>.
</div>

<div algorithm>
The <dfn method for=FileSystemDirectoryHandle>getFile(|name|, |options|)</dfn> method, when invoked,
must run these steps:

1. TODO

</div>

### The {{FileSystemDirectoryHandle/getDirectory()}} method ### {#api-filesystemdirectoryhandle-getdirectory}

<div class="note domintro">
  : |subdirHandle| = await |directoryHandle| . {{FileSystemDirectoryHandle/getDirectory()|getDirectory}}(|name|)
  : |subdirHandle| = await |directoryHandle| . {{FileSystemDirectoryHandle/getDirectory()|getDirectory}}(|name|, { {{FileSystemGetDirectoryOptions/create}}: false })
  :: Returns a handle for a directory named |name| in the directory represented by
    |directoryHandle|. If no such directory exists, this rejects.

  : |subdirHandle| = await |directoryHandle| . {{FileSystemDirectoryHandle/getDirectory()|getDirectory}}(|name|, { {{FileSystemGetDirectoryOptions/create}}: true })
  :: Returns a handle for a directory named |name| in the directory represented by
     |directoryHandle|. If no such directory exists, this creates a new directory. If creating the
     directory failed, this rejects. Creation can fail because there already is a file with the same
     name, or because the name uses characters that aren't supported in file names on the underlying
     file system.

     This operation requires write permission, even if the directory being returned already exists.
     If this handle doesn't already have write permission, this could result in a prompt being shown
     to the user. To get an existing directory without needing write permission, call this method
     with <code>{ {{FileSystemGetDirectoryOptions/create}}: false }</code>.
</div>

<div algorithm>
The <dfn method for=FileSystemDirectoryHandle>getDirectory(|name|, |options|)</dfn> method, when
invoked, must run these steps:

1. TODO

</div>

### The {{FileSystemDirectoryHandle/getEntries()}} method ### {#api-filesystemdirectoryhandle-getentries}

<div class="note domintro">
  : for await (const |handle| of |directoryHandle| . {{FileSystemDirectoryHandle/getEntries()}}) {}
  :: Iterates over all entries whose parent is the entry represented by |directoryHandle|.
</div>

<div algorithm>
The <dfn method for=FileSystemDirectoryHandle>getEntries()</dfn> method, when invoked, must run
these steps:

1. TODO

</div>

### The {{FileSystemDirectoryHandle/resolve()}} method ### {#api-filesystemdirectoryhandle-resolve}

<div class="note domintro">
  : |relativePath| = await |directoryHandle| . {{FileSystemDirectoryHandle/resolve()|resolve}}(|otherHandle|)
  :: If |otherHandle| is a descendant of |directoryHandle|, returns an array representing the path
     you can take to get from |directoryHandle| to |otherHandle|.

     For example if |otherHandle| is a direct child of |directoryHandle|,
     |relativePath| will be equal to an array containing just |otherHandle|.name.

     If |otherHandle| isn't a descendant of |directoryHandle|, resolves with `null`.

     If |otherHandle| represents the same entry as |directoryHandle|, resolves with an empty array.

     If for whatever reason |directoryHandle| or |otherHandle| isn't readable, rejects with some
     exception.
</div>

<div algorithm>
The <dfn method for=FileSystemDirectoryHandle>resolve(|handle|)</dfn> method, when invoked, must run
these steps:

1. TODO

</div>

### The {{FileSystemDirectoryHandle/removeEntry()}} method ### {#api-filesystemdirectoryhandle-removeentry}

<div class="note domintro">
  : await |directoryHandle| . {{FileSystemDirectoryHandle/removeEntry()|removeEntry}}(|name|)
  : await |directoryHandle| . {{FileSystemDirectoryHandle/removeEntry()|removeEntry}}(|name|, { {{FileSystemRemoveOptions/recursive}}: false })
  :: If the directory represented by |directoryHandle| contains a file named |name|, or an empty
     directory named |name|, this will attempt to delete that file or directory.

     Attempting to delete a file or directory that does not exist is considered success,
     while attempting to delete a non-empty directory will result in a promise rejection.

  : await |directoryHandle| . {{FileSystemDirectoryHandle/removeEntry()|removeEntry}}(|name|, { {{FileSystemRemoveOptions/recursive}}: true })
  :: Removes the entry named |name| in the directory represented by |directoryHandle|.
     If that entry is a directory, its contents will also be deleted recursively.
     recursively.

     Attempting to delete a file or directory that does not exist is considered success.
</div>

<div algorithm>
The <dfn method for=FileSystemDirectoryHandle>removeEntry(|name|, |options|)</dfn> method, when invoked, must run
these steps:

1. TODO

</div>

## The {{FileSystemWriter}} interface ## {#api-filesystemwriter}

<xmp class=idl>
[Exposed=(Window,Worker), SecureContext]
interface FileSystemWriter {
  Promise<void> write(unsigned long long position, (BufferSource or Blob or USVString) data);
  WritableStream asWritableStream();
  Promise<void> truncate(unsigned long long size);
  Promise<void> flush();
  Promise<void> close();
};
</xmp>

A {{FileSystemWriter}} has an associated <dfn for=FileSystemWriter>atomic flag</dfn>.

### The {{FileSystemWriter/write()}} method ### {#api-filesystemwriter-write}

<div class="note domintro">
  : await |writer| . {{FileSystemWriter/write()|write}}(|position|, |data|)
  :: Writes the content of |data| into the file associated with |writer| at position |position|.
     If |position| is past the end of the file writing will fail and this method rejects.

     There are no guarantees that the data written to the file using this method is actually
     reflected in the file on disk until the {{FileSystemWriter/close()}} or
     {{FileSystemWriter/flush()}} methods are called. Specifically when |writer|'s
     [=atomic flag=] is set, the user agent will ensure that no changes are written to the actual
     file until one of those methods is called.
</div>

<div algorithm>
The <dfn method for=FileSystemWriter>write(|position|, |data|)</dfn> method, when invoked, must run
these steps:

1. TODO

</div>

### The {{FileSystemWriter/asWritableStream()}} method ### {#api-filesystemwriter-aswritablestream}

Issue(19): The functionality described by this method will likely stay, but the exact shape of
the method is still in flux even more than the rest of this specification.

<div class="note domintro">
  : let |stream| = |writer| . {{FileSystemWriter/asWritableStream()}}
  :: Returns a {{WritableStream}} that can be used to write data into the file, starting
     at the beginning of the file.

     There are no guarantees that the data written to the file using this method is actually
     reflected in the file on disk until the {{FileSystemWriter/close()}} or
     {{FileSystemWriter/flush()}} methods are called. Specifically when |writer|'s
     [=atomic flag=] is set, the user agent will ensure that no changes are written to the actual
     file until one of those methods is called.
</div>

<div algorithm>
The <dfn method for=FileSystemWriter>asWritableStream()</dfn> method, when invoked,
must run these steps:

1. TODO

</div>

### The {{FileSystemWriter/truncate()}} method ### {#api-filesystemwriter-truncate}

<div class="note domintro">
  : await |writer| . {{FileSystemWriter/truncate()|truncate}}(|size|)
  :: Resizes the file associated with |writer| to be |size| bytes long. If |size| is larger than
     the current file size this pads the file with zero bytes, otherwise it truncates the file.

     There are no guarantees that the changes made to the file using this method are actually
     reflected in the file on disk until the {{FileSystemWriter/close()}} or
     {{FileSystemWriter/flush()}} methods are called. Specifically when |writer|'s
     [=atomic flag=] is set, the user agent will ensure that no changes are written to the actual
     file until one of those methods is called.
</div>

<div algorithm>
The <dfn method for=FileSystemWriter>truncate(|size|)</dfn> method, when invoked, must run these
steps:

1. TODO

</div>

### The {{FileSystemWriter/flush()}} method ### {#api-filesystemwriter-flush}

<div class="note domintro">
  : await |writer| . {{FileSystemWriter/flush()}}
  :: Flushes any data written so far to disk. If |writer|'s [=atomic flag=] is set, no changes will
     be visible in the file until this method (or {{FileSystemWriter/close()}}) is called.
     Furthermore, if the file on disk changed between creating this |writer| (or the last time
     {{FileSystemWriter/flush()}} was called) and this invocation of{{FileSystemWriter/flush()}},
     this will reject and all future operations on the writer will fail.

     This operation can take some time to complete (even if the |writer|'s [=atomic flag=] is not
     set), as user agents might use this moment to run malware scanners or perform other security
     checks if the website isn't sufficiently trusted.
</div>

<div algorithm>
The <dfn method for=FileSystemWriter>flush()</dfn> method, when invoked, must run these
steps:

1. TODO

</div>

### The {{FileSystemWriter/close()}} method ### {#api-filesystemwriter-close}

<div class="note domintro">
  : await |writer| . {{FileSystemWriter/close()}}
  :: First flushes any data written so far to disk, like invoking the {{FileSystemWriter/flush()}}
     method does, and then closes the writer. If a |writer|'s [=atomic flag=] is set calling
     {{FileSystemWriter/close()}} can be more efficient than calling {{FileSystemWriter/flush()}},
     since this tells the user agent that no more writes to the file will be made using this writer.

     Like {{FileSystemWriter/flush()}}, this operation can take some time to complete (even if the
     |writer|'s [=atomic flag=] is not set), as user agents might use this moment to run malware
     scanners or perform other security checks if the website isn't sufficiently trusted.
</div>

<div algorithm>
The <dfn method for=FileSystemWriter>close()</dfn> method, when invoked, must run these
steps:

1. TODO

</div>

# Accessing native filesystem # {#native-filesystem}

## The {{Window/chooseFileSystemEntries()}} method ## {#api-choosefilesystementries}

<xmp class=idl>
enum ChooseFileSystemEntriesType { "openFile", "saveFile", "openDirectory" };

dictionary ChooseFileSystemEntriesOptionsAccepts {
  USVString description;
  sequence<USVString> mimeTypes;
  sequence<USVString> extensions;
};

dictionary ChooseFileSystemEntriesOptions {
    ChooseFileSystemEntriesType type = "openFile";
    boolean multiple = false;
    sequence<ChooseFileSystemEntriesOptionsAccepts> accepts;
    boolean excludeAcceptAllOption = false;
};

[SecureContext]
partial interface Window {
    Promise<(FileSystemHandle or sequence<FileSystemHandle>)>
        chooseFileSystemEntries(optional ChooseFileSystemEntriesOptions options);
};
</xmp>

<div class="note domintro">
  : |result| = await window . {{Window/chooseFileSystemEntries()|chooseFileSystemEntries}}(|options|)
  :: Shows a file picker dialog to the user and returns handles for the selected files or
     directories.

     The |options| argument sets options that influence the behavior of the shown file picker.

     |options|.{{ChooseFileSystemEntriesOptions/type}} specifies the type of the entry the website
     wants the user to pick. When set to {{ChooseFileSystemEntriesType/"openFile"}} (the default),
     the user can select only existing files. When set to {{ChooseFileSystemEntriesType/"saveFile"}}
     the dialog will additionally let the user select files that don't yet exist. Finally when set
     to {{ChooseFileSystemEntriesType/"openDirectory"}}, the dialog will let the user select
     directories instead of files.

     If |options|.{{ChooseFileSystemEntriesOptions/multiple}} is false (or absent) the user can
     only select a single file, and the |result| will be a single {{FileSystemHandle}}. If on the
     other hand |options|.{{ChooseFileSystemEntriesOptions/multiple}} is true, the dialog can let
     the user select more than one file, and |result| will be an array of {{FileSystemHandle}}
     instances (even if the user did select a single file, if
     {{ChooseFileSystemEntriesOptions/multiple}} is true this will be returned as a single-element
     array).

     Finally |options|.{{ChooseFileSystemEntriesOptions/accepts}} and
     |options|.{{ChooseFileSystemEntriesOptions/excludeAcceptAllOption}} specify the types of files
     the dialog will let the user select. Each entry in
     |options|.{{ChooseFileSystemEntriesOptions/accepts}} describes a single type of file,
     consisting of a {{ChooseFileSystemEntriesOptionsAccepts/description}}, zero or more
     {{ChooseFileSystemEntriesOptionsAccepts/mimeTypes}} and zero or more
     {{ChooseFileSystemEntriesOptionsAccepts/extensions}}. Options with no valid
     {{ChooseFileSystemEntriesOptionsAccepts/mimeTypes}} and no
     {{ChooseFileSystemEntriesOptionsAccepts/extensions}} are invalid and are ignored. If no
     {{ChooseFileSystemEntriesOptionsAccepts/description}} is provided one will be generated.

     If |options|.{{ChooseFileSystemEntriesOptions/excludeAcceptAllOption}} is true, or if no valid
     entries exist in |options|.{{ChooseFileSystemEntriesOptions/accepts}}, a option matching all
     files will be included in the file types the dialog lets the user select.
</div>

<div algorithm>
The <dfn method for=Window>chooseFileSystemEntries(|options|)</dfn> method, when invoked, must run
these steps:

1. TODO

</div>

# Accessing special filesystems # {#special-filesystems}

## The {{FileSystemDirectoryHandle/getSystemDirectory()}} method ## {#api-getsystemdirectory}

<xmp class=idl>
enum SystemDirectoryType {
  "sandbox"
};

dictionary GetSystemDirectoryOptions {
  required SystemDirectoryType type;
};

[SecureContext]
partial interface FileSystemDirectoryHandle {
  static Promise<FileSystemDirectoryHandle> getSystemDirectory(GetSystemDirectoryOptions options);
};
</xmp>

<div class="note domintro">
  : |directoryHandle| = {{FileSystemDirectoryHandle}} .
    {{FileSystemDirectoryHandle/getSystemDirectory()|getSystemDirectory}}({
       {{GetSystemDirectoryOptions/type}}: {{SystemDirectoryType/"sandbox"}} })
  :: Returns the sandboxed filesystem.
</div>

Issue(27): getSystemDirectory might not be the best name. Also perhaps should be on Window rather
than on FileSystemDirectoryHandle.

<div algorithm>
The <dfn method for=FileSystemDirectoryHandle>getSystemDirectory(|options|)</dfn> method, when
invoked, must run these steps:

1. TODO

</div>

# Security Considerations # {#security-considerations}

## Secure Context ## {#secure-context}

## Limiting types of files that can be written to ## {#file-type-limitations}
